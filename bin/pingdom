#!/usr/bin/env bash

set -euo pipefail

BASE_DIR=$(dirname $(readlink -f $0))/..
PINGDOM=https://api.pingdom.com/api/3.1
typeset -A TEMPLATE_ARGS
TEMPLATE_DIR=$BASE_DIR/templates
WORK_DIR=$BASE_DIR/work
SECRETS_FILE=secrets.conf
# We'll use $SED_SEPARATOR as a sed separator since this would not naturally occur
# but, just in case it might, we can make it a configurable option later
SED_SEPARATOR="^"
CURL_VERBOSE=-s

usage() {
  cat<<EOF
$0 <command> [options]

Options:
--debug                Enable debugging output
--token <api-token>    Specify Pingdom API token with Read-Write permission (env PINGDOM_TOKEN)
--secrets <file>       Bash file that will be sourced if present (env SECRETS_FILE=$SECRETS_FILE)
-a, --template-args <key=value>
                       Specify a template argument substitution parameter
Commands:
get-check <check-id>
  Get details for a specific check.
get-checks
  Get a listing of all checks.
process-template <template> --template-args key=value ...
  Process a template, but do not save.
save-check <template> --template-args key=value ...
  Process a template and save it, creating a new one or updating an existing entry by the same check name.
${1:-}

Example:
$0 save-check https-public-200 \\
  -a name=dstu2-metadata \\
  -a url=/services/fhir/v0/dstu2/metadata \\
  -a resolution=1 \\
  -a group=health-apis \\
  -a responsetime_threshold=5000 \\
  -a port=443 \\
  -a host=api.va.gov \\
  -a integrationids_csv=100343
EOF
  exit 1
}


initialize() {
  if [ -d $WORK_DIR ]; then rm -rf $WORK_DIR; fi
  mkdir -p $WORK_DIR
}

processCommandLine() {
  local args
  if ! args=$(getopt -n "application" \
    -l "debug,token:,secrets:,template-arg:" \
    -o "a:" -- "$@")
  then
    usage
   fi
  eval set -- "$args"
  while true
  do
    case "$1" in
      --debug) set -x; CURL_VERBOSE=-v;;
      --token) PINGDOM_TOKEN="$2";;
      --secrets) SECRETS_FILE="$2";;
      -a|--template-arg) addTemplateArg "$2";;
      --) shift; break;;
    esac
    shift
  done
  COMMAND="${1:-}"
  if [ -z "$COMMAND" ]; then usage "Command not specified"; fi
  shift
  if [ -f "$SECRETS_FILE" ]; then . $SECRETS_FILE; fi
  case "$COMMAND" in
    get-checks) getChecks;;
    get-check) getCheck "${1:-}";;
    process-template) processTemplate "${1:-}" /dev/stdout;;
    save-check) saveCheck "${1:-}";;
    *) usage "Unknown command: $COMMAND";;
  esac
}

addTemplateArg() {
  local nameEqValue="${1:-}"
  if [[ ! "$nameEqValue" =~ ([-a-zA-Z0-9_]+)=(.*) ]]; then usage "Invalid template argument"; fi
  local name="${BASH_REMATCH[1]}"
  local value="${BASH_REMATCH[2]}"
  TEMPLATE_ARGS[$name]="$value"
}

tokenOrDie() {
  if [ -z "${PINGDOM_TOKEN:-}" ]; then usage "Token not specified"; fi
}


curlPingdom() {
  local path="$1"
  tokenOrDie
  shift
  curl \
    $CURL_VERBOSE \
    -H "Authorization: Bearer $PINGDOM_TOKEN" \
    -H "Accept: application/json" \
    "$@" \
    $PINGDOM$path
}

getChecks() {
  curlPingdom /checks
}

getCheck() {
  local checkId="$1"
  if [ -z "${checkId}" ]; then usage "Check ID not specified"; fi
  curlPingdom /checks/$checkId
}

processTemplate() {
  local templateName="$1"
  local output="$2"
  if [ -z "$templateName" ]; then usage "Template not specified"; fi
  local templateFile=$TEMPLATE_DIR/$templateName.json
  if [ ! -f "$templateFile" ]; then usage "Template not found"; fi
  local requiredTemplateArgs=$(grep -oE '\$[-a-zA-Z0-0_]+' $templateFile|tr -d \$)
  local missingArguments=false
  local subst=
  for arg in $requiredTemplateArgs
  do
    if [ -z "${TEMPLATE_ARGS[$arg]:-}" ]
    then
      missingArguments=true
      echo "Missing template argument: $arg"
    else
      subst+=" -e s${SED_SEPARATOR}\\\$$arg${SED_SEPARATOR}${TEMPLATE_ARGS[$arg]}${SED_SEPARATOR}g"
    fi
  done
  if [ $missingArguments == true ]; then exit 1; fi
  sed $subst $templateFile > $output
}


getExistingCheckIdForName() {
  local name="$1"
  getChecks | jq -r ".checks[]|select(.name==\"$name\")|.id"
}

removeType() {
  local output="$1"
  sed -i '/^ \+"type":/d' $output
}

saveCheck() {
  local templateName="$1"
  local output=$(mktemp -p $WORK_DIR check.XXXXX)
  processTemplate $templateName $output
  # All checks must have a name.
  local name="$(jq -r .name $output)"
  local id=$(getExistingCheckIdForName $name)
  if [ -n "$id" ]
  then
    echo "Updating check $name ($id)";
    removeType $output
    cat $output
    curlPingdom /checks/$id -X PUT -d @$output -H "Content-Type: application/json"
  else
    echo "Creating check $name"
    cat $output
    curlPingdom /checks -X POST -d @$output -H "Content-Type: application/json"
  fi
}

#============================================================
initialize
processCommandLine $@
exit 0
